{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-viewer-app",
  "type": "registry:block",
  "dependencies": [
    "@radix-ui/react-visually-hidden",
    "js-base64",
    "jsonpath-plus",
    "json-bigint",
    "json5",
    "json5-bigint",
    "shiki",
    "tm-themes",
    "yaml"
  ],
  "devDependencies": [
    "@types/json-bigint",
    "tailwind-scrollbar"
  ],
  "registryDependencies": [
    "button",
    "button-group",
    "dialog",
    "dropdown-menu",
    "input",
    "input-group",
    "separator",
    "sonner",
    "textarea",
    "tooltip"
  ],
  "files": [
    {
      "path": "src/components/ui/conanyu/data-viewer.tsx",
      "content": "// https://github.com/conanyu/data-viewer/blob/main/app/page/src/components/ui/conanyu/data-viewer.tsx\n\n'use client';\n\nimport JSONBigInt from 'json-bigint';\nimport JSON5Normal from 'json5';\nimport JSON5BigInt from 'json5-bigint';\nimport YAML from 'yaml';\nimport { ButtonGroup } from '@/components/ui/button-group.tsx';\nimport {\n  type ComponentProps,\n  type MouseEventHandler,\n  type ReactNode,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip.tsx';\nimport { cn } from '@/lib/utils.ts';\nimport { buttonVariants } from '@/components/ui/button.tsx';\nimport {\n  CircleArrowUp,\n  CircleChevronDown,\n  CircleChevronUp,\n  CircleMinus,\n  CirclePlus,\n  CircleQuestionMark,\n  CopyIcon,\n  Ellipsis,\n  EyeOff,\n  LoaderCircle,\n  Maximize,\n  Sparkle,\n  SquarePen,\n} from 'lucide-react';\nimport { toast } from 'sonner';\nimport { Toaster } from '@/components/ui/sonner.tsx';\nimport {\n  createHighlighter,\n  createJavaScriptRegexEngine,\n  type HighlighterGeneric,\n  type ThemeRegistration,\n  type TokensResult,\n} from 'shiki';\nimport { Dialog, DialogContent, DialogTitle, DialogTrigger } from '@/components/ui/dialog.tsx';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\nimport {\n  DropdownMenu,\n  DropdownMenuCheckboxItem,\n  DropdownMenuContent,\n  DropdownMenuGroup,\n  DropdownMenuItem,\n  DropdownMenuLabel,\n  DropdownMenuShortcut,\n  DropdownMenuTrigger,\n} from '@/components/ui/dropdown-menu.tsx';\nimport { Textarea } from '@/components/ui/textarea.tsx';\nimport { Button } from '@/components/ui/button.tsx';\nimport { Input } from '@/components/ui/input.tsx';\nimport * as DialogPrimitive from '@radix-ui/react-dialog';\nimport { InputGroup, InputGroupAddon, InputGroupButton, InputGroupInput } from '@/components/ui/input-group.tsx';\nimport { JSONPath } from 'jsonpath-plus';\nimport { Base64 } from 'js-base64';\nimport OneLight from 'tm-themes/themes/one-light.json';\n\nconst isSupportBigInt = typeof BigInt !== 'undefined' && !(window as any).__conanyu_data_viewer_no_bigint;\n\nconst JSONHandler = isSupportBigInt ? JSONBigInt({ useNativeBigInt: true }) : JSON;\nconst JSON5 = isSupportBigInt ? JSON5BigInt : JSON5Normal;\n\n// 转化逻辑\nconst dataType = ['json', 'json5', 'yaml'] as const;\ntype DataType = (typeof dataType)[number];\n\ntype AutoDetectFunc = (text: string) => unknown;\nconst autoDetectMap: Record<DataType, AutoDetectFunc> = {\n  json: JSONHandler.parse,\n  json5: JSON5.parse,\n  yaml: (text: string) => YAML.parse(text, { intAsBigInt: isSupportBigInt }),\n};\n\ntype StringifyFunc = (data: unknown) => string;\nconst stringifyPrettyMap: Record<DataType, StringifyFunc> = {\n  json: (data: unknown) => JSONHandler.stringify(data, null, 2),\n  json5: (data: unknown) => JSONHandler.stringify(data, null, 2), // 即使原本是JSON5，也依旧使用JSON序列化\n  yaml: (data: unknown) => YAML.stringify(data, { intAsBigInt: isSupportBigInt, indent: 2 }),\n};\n\nfunction autoDetect(props: { data: string; type?: DataType }):\n  | {\n      type: 'error';\n      data: undefined;\n      error: string;\n    }\n  | {\n      type: DataType;\n      data: unknown;\n      error: undefined;\n    } {\n  const { data, type } = props;\n  if (!type) {\n    let error;\n    for (const type of dataType) {\n      let result = undefined;\n      try {\n        result = autoDetectMap[type](data);\n      } catch (e) {\n        if (type === 'json5') {\n          error = e;\n        }\n      }\n      if (result === undefined) {\n        continue;\n      }\n      if (type === 'yaml' && (result === null || ['bigint', 'number', 'string', 'boolean'].includes(typeof result))) {\n        continue;\n      }\n      return { type, data: result, error: undefined };\n    }\n    return { type: 'error', error: `${error}`, data: undefined };\n  }\n  try {\n    return { type, data: autoDetectMap[type](data), error: undefined };\n  } catch (e) {\n    return { type: 'error', error: `${e}`, data: undefined };\n  }\n}\n\n// 交互逻辑\ntype InteractionResult =\n  | {\n      event?:\n        | ((e: MouseEvent) => void) // 点击回调\n        | ReactNode; // 弹窗\n      title?: ReactNode; // Tooltip 文案\n      highPriority?: boolean; // 是否高优先级\n    }\n  | undefined;\n\ntype Interaction = (r: {\n  data: unknown;\n  depth: number;\n  config?: DataViewerConfig;\n  onDataChange?: (data: unknown) => void;\n  pointer: string;\n}) => InteractionResult;\n\nconst TooltipButton = ({\n  tooltip,\n  icon,\n  onClick,\n  link,\n}: {\n  tooltip: ReactNode;\n  icon: ReactNode;\n  onClick?: () => void;\n  link?: string;\n}) => {\n  return (\n    <Tooltip>\n      <TooltipTrigger\n        className={buttonVariants({\n          variant: 'outline',\n          size: 'icon',\n          className: 'cursor-pointer bg-white text-gray-600',\n        })}\n        onClick={onClick}\n      >\n        {link ? (\n          <a href={link} onClick={e => e.preventDefault()}>\n            {icon}\n          </a>\n        ) : (\n          icon\n        )}\n      </TooltipTrigger>\n      <TooltipContent>{tooltip}</TooltipContent>\n    </Tooltip>\n  );\n};\n\nfunction LongTextDialogContent({ data, config }: { data: string; config?: DataViewerConfig }) {\n  const [showToolbar, setShowToolbar] = useState(true);\n\n  return (\n    <div className=\"relative overflow-auto scrollbar-thin border-2 rounded-md\">\n      <pre\n        className={cn(\n          showToolbar ? 'overflow-y-scroll' : 'overflow-auto',\n          'scrollbar-thin max-h-[80vh] p-4 text-sm font-mono whitespace-pre-wrap break-all',\n        )}\n        style={{\n          backgroundColor: config?.themeInfo?.bg || config?.themeInfo?.colors?.['editor.background'],\n          color: config?.themeInfo?.fg || config?.themeInfo?.colors?.['editor.foreground'],\n        }}\n      >\n        {data}\n      </pre>\n      <div className={cn('absolute right-4 top-2', !showToolbar && 'hidden')}>\n        <ButtonGroup>\n          <div className={buttonVariants({ variant: 'outline' })}>长文本</div>\n          <TooltipButton\n            tooltip=\"复制\"\n            icon={<CopyIcon />}\n            onClick={async () => {\n              await navigator.clipboard.writeText(data);\n              toast.success('复制成功');\n            }}\n          />\n          <TooltipButton tooltip=\"隐藏工具栏\" icon={<EyeOff />} onClick={() => setShowToolbar(false)} />\n        </ButtonGroup>\n      </div>\n    </div>\n  );\n}\n\nconst defaultInteraction: Interaction = ({ data, depth, config, onDataChange, pointer }) => {\n  const length = collapseLength(data);\n  const viewer = (data: unknown, title?: string, callback?: (v: unknown) => void) => {\n    return (\n      <DataViewerIntl\n        data={JSONHandler.stringify(data)}\n        title={title}\n        config={{ ...config, withToaster: false, withoutMaximize: true }}\n        className=\"border-2 rounded-md\"\n        preClassName=\"max-h-[80vh]\"\n        onDataChange={callback ?? onDataChange}\n        pointer={pointer}\n      />\n    );\n  };\n  if (depth > 0 && length > 0) {\n    return {\n      event: viewer(data, 'JSON'),\n      title: 'JSON',\n    };\n  }\n  if (typeof data === 'string' && data) {\n    if (data.startsWith('https://') || data.startsWith('http://')) {\n      return {\n        event: () => window.open(data, '_blank'),\n        title: '链接',\n      };\n    }\n    const tryParseResult = autoDetect({ data });\n    if (typeof tryParseResult.error !== 'string') {\n      const { type, data } = tryParseResult;\n      if (\n        (type !== 'yaml' && !['number', 'bigint'].includes(typeof data)) ||\n        (type === 'yaml' && !['string', 'number', 'bigint'].includes(typeof data))\n      ) {\n        const title = type === 'json' ? 'JSON' : type === 'json5' ? 'JSON5' : 'YAML';\n        let callback;\n        switch (type) {\n          case 'json':\n            callback = (v: unknown) => onDataChange?.(JSONHandler.stringify(v));\n            break;\n          case 'json5':\n            callback = (v: unknown) => onDataChange?.(JSON5.stringify(v));\n            break;\n          case 'yaml':\n            callback = (v: unknown) => onDataChange?.(YAML.stringify(v, { intAsBigInt: isSupportBigInt, indent: 2 }));\n            break;\n        }\n        return {\n          event: viewer(data, title, callback),\n          title,\n        };\n      }\n    }\n    try {\n      const getValidStringRatio = (str: string): number => {\n        if (!str) {\n          return 0.0;\n        }\n        // 定义有效字符的Unicode范围（可根据业务调整）\n        // 1. 中文：U+4E00-U+9FFF（中日韩统一表意文字）\n        // 2. 中文标点：U+3000-U+303F（全角标点）、U+FF00-U+FFEF（半角全角转换区）\n        // 3. 英文/基本符号：U+0020-U+007E（ASCII可打印字符）\n        // 4. 换行相关：CR(\\r/U+000D)、LF(\\n/U+000A)、Unicode行/段落分隔符\n        const validCharRegex = /[\\u4E00-\\u9FFF\\u3000-\\u303F\\uFF00-\\uFFEF\\u0020-\\u007E\\r\\n\\u2028\\u2029]/;\n        let validCount = 0;\n        for (const char of str) {\n          if (validCharRegex.test(char)) {\n            validCount++;\n          }\n        }\n        // 计算有效字符比例\n        return validCount / str.length;\n      };\n      const decodedString = Base64.decode(data);\n      const confidence = getValidStringRatio(decodedString);\n      if ((data.length < 10 && confidence >= 1) || (data.length >= 10 && confidence >= 0.99)) {\n        return {\n          event: viewer(decodedString, 'Base64', v => {\n            onDataChange?.(Base64.encode(typeof v === 'string' ? v : JSONHandler.stringify(v)));\n          }),\n          title: 'Base64',\n        };\n      }\n    } catch (e) {}\n\n    if (data.length > (config?.showInteractionWithStringLengthGte ?? 100)) {\n      return {\n        event: <LongTextDialogContent data={data} config={config} />,\n        title: '长文本',\n      };\n    }\n  }\n  return undefined;\n};\n\n// 内部组件\ninterface InnerViewerProps {\n  themeInfo: ThemeRegistration;\n  node: ViewerNode;\n  mode: 'normal' | 'edit';\n  onValueChange: (v: unknown) => void;\n  config?: DataViewerConfig;\n  onMove?: (e: 'up' | 'down') => void;\n  pointer: string;\n}\n\nfunction collapseLength(v: unknown): number {\n  return typeof v === 'object' && v !== null ? Object.keys(v).length : 0;\n}\n\nconst isNotMac = !/Mac|iPhone|iPod|iPad/i.test(navigator.userAgent);\n\nfunction InteractionCircle({\n  onClick,\n  className,\n  themeInfo,\n}: {\n  onClick: (e: MouseEvent) => void;\n  className?: string;\n  themeInfo: ThemeRegistration;\n}) {\n  const [hover, setHover] = useState(false);\n  return (\n    <span\n      className={cn('font-sans select-none cursor-pointer opacity-70 hover:opacity-100', className)}\n      onMouseEnter={() => setHover(true)}\n      onMouseLeave={() => setHover(false)}\n      onClick={e => onClick(e.nativeEvent)}\n      style={{\n        color: hover\n          ? themeInfo.colors?.['button.hoverBackground'] || themeInfo.colors?.['button.background']\n          : themeInfo.colors?.['button.background'],\n      }}\n    >\n      <div className={cn('w-2.5 h-2.5 rounded-full bg-current', isNotMac && 'relative top-[0.1rem]')} />\n    </span>\n  );\n}\n\nfunction InteractionTriangle({\n  themeInfo,\n  onClick,\n  collapsed,\n}: {\n  themeInfo: ThemeRegistration;\n  onClick: (e: MouseEvent) => void;\n  collapsed: boolean;\n}) {\n  const [hover, setHover] = useState(false);\n  return (\n    <span\n      className={cn(\n        'cursor-pointer absolute text-center left-4 select-none top-[-0.2rem] text-base opacity-70',\n        isNotMac && 'top-[-0.1rem]',\n        collapsed && 'rotate-270',\n      )}\n      onClick={e => onClick(e.nativeEvent)}\n      onMouseEnter={() => setHover(true)}\n      onMouseLeave={() => setHover(false)}\n      style={{\n        color: hover\n          ? themeInfo.colors?.['button.hoverBackground'] || themeInfo.colors?.['button.background']\n          : themeInfo.colors?.['button.background'],\n      }}\n    >\n      {'\\u25BC'}\n    </span>\n  );\n}\n\nfunction UpdateValueDialogContent({\n  isArray,\n  onSubmitValue,\n  config,\n  defaultKey,\n  defaultValue,\n  ...props\n}: ComponentProps<typeof DialogPrimitive.Content> & {\n  isArray: boolean;\n  onSubmitValue: (k: string, v: unknown) => void;\n  config?: DataViewerConfig;\n  defaultKey?: string;\n  defaultValue?: string;\n}) {\n  const [key, setKey] = useState(defaultKey || '');\n  const [value, setValue] = useState(defaultValue || '\"输入数据\"');\n  const data = useMemo(() => autoDetect({ data: value, type: config?.type }), [value, config?.type]);\n  useEffect(() => setKey(defaultKey || ''), [defaultKey]);\n  useEffect(() => setValue(defaultValue || '\"输入数据\"'), [defaultValue]);\n  return (\n    <DialogContent\n      className=\"w-full max-w-[60vw]!\"\n      onOpenAutoFocus={e => e.preventDefault()}\n      showCloseButton={false}\n      aria-describedby={undefined}\n      {...props}\n    >\n      <VisuallyHidden asChild>\n        <DialogTitle />\n      </VisuallyHidden>\n      <div className=\"flex gap-4\">\n        <div className=\"h-[calc(60vh-2rem)]\">\n          {isArray ? (\n            <Textarea\n              className=\"w-[calc(30vw-1.75rem)] h-full resize-none scrollbar-thin bg-gray-100\"\n              value={value}\n              onChange={e => setValue(e.target.value)}\n              placeholder=\"输入数据\"\n            />\n          ) : (\n            <>\n              <Input\n                disabled={!!defaultKey}\n                className=\"w-[calc(30vw-1.75rem)] mb-4 bg-gray-100\"\n                placeholder=\"输入KEY\"\n                value={key}\n                onChange={e => setKey(e.target.value)}\n              />\n              <Textarea\n                className=\"w-[calc(30vw-1.75rem)] h-[calc(60vh-5.25rem)] resize-none scrollbar-thin bg-gray-100\"\n                value={value}\n                onChange={e => setValue(e.target.value)}\n                placeholder=\"输入数据\"\n              />\n            </>\n          )}\n        </div>\n        <div className=\"border-2 rounded-md w-[calc(30vw-2.25rem)] h-[calc(60vh-2rem)] relative\">\n          <DataViewer\n            className=\"rounded-md h-full\"\n            preClassName=\"h-full\"\n            data={value}\n            onDataChange={value => {\n              for (const type of dataType) {\n                if (type === data.type) {\n                  setValue(stringifyPrettyMap[type](value));\n                  break;\n                }\n              }\n            }}\n            config={{ ...config, withToaster: false, withoutMaximize: true }}\n          />\n          <Button\n            className=\"absolute bottom-3 right-5 cursor-pointer\"\n            size=\"sm\"\n            disabled={(!isArray && !key) || !!data.error}\n            onClick={() => onSubmitValue(key, data.data)}\n          >\n            确认\n          </Button>\n        </div>\n      </div>\n    </DialogContent>\n  );\n}\n\nfunction InnerViewer(props: InnerViewerProps) {\n  const { node, config, themeInfo, mode, onValueChange, onMove, pointer } = props;\n  const { openMove } = config || {};\n  const [collapsed, setCollapsed] = useState(false);\n  const [keyHover, setKeyHover] = useState(false);\n  const [addDialogOpen, setAddDialogOpen] = useState(false);\n  const [updateDialogOpen, setUpdateDialogOpen] = useState(false);\n\n  const interaction = useMemo(() => {\n    const props = { data: node.data, depth: node.depth, config, onDataChange: onValueChange, pointer };\n    const interaction = config?.additionalInteraction?.(props);\n    if (interaction?.highPriority) {\n      return interaction;\n    }\n    return defaultInteraction(props) || interaction;\n  }, [node, config?.additionalInteraction]);\n\n  let interactionTrigger: ReactNode = null;\n\n  const updateInteraction = (\n    <Dialog open={updateDialogOpen} onOpenChange={setUpdateDialogOpen} key=\"interaction-arrow-up\">\n      <DialogTrigger>\n        <CircleArrowUp\n          className=\"inline-block align-text-top w-3 h-3 mt-0.5 cursor-pointer mx-0.5\"\n          style={{ color: themeInfo.colors?.['button.background'] }}\n        />\n      </DialogTrigger>\n      <UpdateValueDialogContent\n        isArray={!node.key}\n        config={config}\n        onSubmitValue={(_, v) => {\n          onValueChange(v);\n          setUpdateDialogOpen(false);\n        }}\n        defaultKey={node.key}\n        defaultValue={JSONHandler.stringify(node.data, null, 2)}\n      />\n    </Dialog>\n  );\n\n  if (mode === 'normal') {\n    if (interaction) {\n      interactionTrigger = (\n        <InteractionCircle\n          key=\"interaction-trigger\"\n          onClick={e => {\n            if (typeof interaction.event === 'function') {\n              interaction.event(e);\n            }\n          }}\n          themeInfo={themeInfo}\n        />\n      );\n      if (interaction.title) {\n        interactionTrigger = (\n          <Tooltip key=\"interaction-tooltip\">\n            <TooltipTrigger>{interactionTrigger}</TooltipTrigger>\n            <TooltipContent>{interaction.title}</TooltipContent>\n          </Tooltip>\n        );\n      }\n      if (typeof interaction.event !== 'function') {\n        interactionTrigger = (\n          <Dialog key=\"interaction-dialog\">\n            <DialogTrigger>{interactionTrigger}</DialogTrigger>\n            <DialogContent\n              showCloseButton={false}\n              autoFocus={false}\n              onOpenAutoFocus={e => e.preventDefault()}\n              className=\"w-full max-w-[80vw]!\"\n              aria-describedby={undefined}\n            >\n              <VisuallyHidden asChild>\n                <DialogTitle />\n              </VisuallyHidden>\n              {interaction.event}\n            </DialogContent>\n          </Dialog>\n        );\n      }\n    }\n  } else if (mode === 'edit') {\n    if (node.depth !== 0) {\n      interactionTrigger = (\n        <span key=\"interaction\">\n          <CircleMinus\n            key=\"interaction-minus\"\n            className=\"inline-block align-text-top w-3 h-3 mt-0.5 cursor-pointer mr-0.5\"\n            onClick={() => onValueChange(undefined)}\n            style={{ color: themeInfo.colors?.['button.background'] }}\n          />\n          {updateInteraction}\n          {openMove && node.collapsedIndex !== 0 && (\n            <CircleChevronUp\n              key=\"interaction-move-up\"\n              className=\"inline-block align-text-top w-3 h-3 mt-0.5 cursor-pointer mx-0.5\"\n              onClick={() => onMove?.('up')}\n              style={{ color: themeInfo.colors?.['button.background'] }}\n            />\n          )}\n          {openMove && node.collapsedIndex !== undefined && node.collapsedIndex + 1 !== node.collapsedLength && (\n            <CircleChevronDown\n              key=\"interaction-move-down\"\n              className=\"inline-block align-text-top w-3 h-3 mt-0.5 cursor-pointer mx-0.5\"\n              onClick={() => onMove?.('down')}\n              style={{ color: themeInfo.colors?.['button.background'] }}\n            />\n          )}\n        </span>\n      );\n    }\n    if (node.data !== null && typeof node.data === 'object') {\n      const isArray = Array.isArray(node.data);\n      if (interactionTrigger !== null) {\n        interactionTrigger = <span className=\"ml-0.5\">{interactionTrigger}</span>;\n      }\n      interactionTrigger = (\n        <span key=\"interaction-plus\">\n          <Dialog open={addDialogOpen} onOpenChange={setAddDialogOpen} key=\"interaction-plus\">\n            <DialogTrigger>\n              <CirclePlus\n                className=\"inline-block align-text-top w-3 h-3 mt-0.5 cursor-pointer mr-0.5\"\n                style={{ color: themeInfo.colors?.['button.background'] }}\n              />\n            </DialogTrigger>\n            <UpdateValueDialogContent\n              isArray={isArray}\n              config={config}\n              onSubmitValue={(k, v) => {\n                if (isArray) {\n                  (node.data as unknown[]).push(v);\n                } else {\n                  (node.data as Record<string, unknown>)[k] = v;\n                }\n                onValueChange(node.data);\n                setAddDialogOpen(false);\n              }}\n            />\n          </Dialog>\n          {node.depth === 0 && updateInteraction}\n          {interactionTrigger}\n        </span>\n      );\n    } else if (node.depth === 0) {\n      interactionTrigger = (\n        <span key=\"interaction-update\">\n          {updateInteraction}\n          {interactionTrigger}\n        </span>\n      );\n    }\n  }\n\n  return (\n    <div className=\"relative\">\n      {node.length > 0 && (\n        <InteractionTriangle\n          onClick={() => {\n            setCollapsed(collapsed => !collapsed);\n          }}\n          collapsed={collapsed}\n          themeInfo={themeInfo}\n        />\n      )}\n      <div className=\"pl-8\">\n        {node.before.map((item, index) => {\n          if (item.type === ViewerContentTypeInteraction) {\n            return (\n              <span key=\"interaction-other\" className={cn(interactionTrigger && 'mr-1')}>\n                {interactionTrigger}\n              </span>\n            );\n          }\n          const canCollapse = item.type === ViewerContentTypeKey && node.length > 0;\n          return (\n            <span\n              key={index}\n              style={{ color: item.color, backgroundColor: item.bgColor }}\n              className={cn(canCollapse && keyHover && 'cursor-pointer')}\n              onMouseEnter={() => canCollapse && setKeyHover(true)}\n              onMouseLeave={() => canCollapse && setKeyHover(false)}\n              onClick={() => {\n                if (canCollapse) {\n                  setCollapsed(collapsed => !collapsed);\n                }\n              }}\n            >\n              {item.content}\n            </span>\n          );\n        })}\n        {collapsed ? (\n          <span\n            style={{ color: themeInfo.fg || themeInfo.colors?.['editor.foreground'] }}\n            className=\"px-3 hover:underline cursor-pointer\"\n            onClick={() => setCollapsed(false)}\n          >\n            {node.length} item{node.length > 1 ? 's' : ''}\n          </span>\n        ) : node.children.length > 0 ? (\n          <div className=\"border-l border-dotted\" style={{ borderColor: themeInfo.colors?.['editor.foreground'] }}>\n            {node.children.map((item, index) => (\n              <InnerViewer\n                key={index}\n                {...props}\n                pointer={\n                  pointer + (item.key ? `/${item.key.replaceAll('~', '~0').replaceAll('/', '~1')}` : `/${index}`)\n                }\n                mode={mode}\n                node={item}\n                onValueChange={value => {\n                  let data = node.data;\n                  if (data !== null) {\n                    if (value === undefined) {\n                      if (Array.isArray(data)) {\n                        data = data.filter((_, i) => i !== index);\n                      } else if (typeof data === 'object') {\n                        const newData: Record<string, unknown> = {};\n                        Object.entries(data).forEach(([key, dataValue], i) => {\n                          if (i !== index) {\n                            newData[key] = dataValue;\n                          }\n                        });\n                        data = newData;\n                      }\n                    } else {\n                      if (Array.isArray(data)) {\n                        data[index] = value;\n                      } else if (typeof data === 'object') {\n                        const newData: Record<string, unknown> = {};\n                        Object.entries(data).forEach(([key, dataValue], i) => {\n                          newData[key] = i !== index ? dataValue : value;\n                        });\n                        data = newData;\n                      }\n                    }\n                    onValueChange(data);\n                  }\n                }}\n                onMove={e => {\n                  let data = node.data;\n                  if (data !== null) {\n                    const swap = (arr: unknown[], i: number, j: number) => {\n                      const temp = arr[i];\n                      arr[i] = arr[j];\n                      arr[j] = temp;\n                    };\n                    const otherIndex = e === 'up' ? index - 1 : index + 1;\n                    if (Array.isArray(data)) {\n                      swap(data, index, otherIndex);\n                    } else if (typeof data === 'object') {\n                      const newDataTemp = Object.entries(data);\n                      swap(newDataTemp, index, otherIndex);\n                      data = Object.fromEntries(newDataTemp);\n                    }\n                  }\n                  onValueChange(data);\n                }}\n              />\n            ))}\n          </div>\n        ) : null}\n        {node.after.map((item, index) => (\n          <span key={index} style={{ color: item.color, backgroundColor: item.bgColor }}>\n            {item.content}\n          </span>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nfunction CanvasInnerViewer(props: InnerViewerProps & { className?: string }) {\n  const { node, config, themeInfo, mode, onValueChange } = props;\n  const bgColor = themeInfo?.bg || themeInfo?.colors?.['editor.background'];\n  const fgColor = themeInfo?.fg || themeInfo?.colors?.['editor.foreground'];\n  // Canvas 模式需要支持任意层级折叠，这里用 pointer 作为 key 维护折叠状态。\n  const [collapsedSet, setCollapsedSet] = useState<Set<string>>(() => new Set());\n\n  type CanvasHitType =\n    | 'toggle-triangle'\n    | 'toggle-key'\n    | 'toggle-collapsed-count'\n    | 'interaction'\n    | 'edit-add'\n    | 'edit-delete'\n    | 'edit-update'\n    | 'edit-move-up'\n    | 'edit-move-down';\n\n  type CanvasHitRegion = {\n    type: CanvasHitType;\n    pointer: string;\n    node: ViewerNode;\n    rect: { x: number; y: number; w: number; h: number };\n  };\n\n  type CanvasRow =\n    | { kind: 'before'; node: ViewerNode; pointer: string; depth: number; collapsed: boolean }\n    | { kind: 'after'; node: ViewerNode; pointer: string; depth: number };\n\n  const scrollRef = useRef<HTMLDivElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const hitRegionsRef = useRef<CanvasHitRegion[]>([]);\n  const rafRef = useRef<number | null>(null);\n  const hoverRef = useRef<Pick<CanvasHitRegion, 'type' | 'pointer'> | null>(null);\n  const scheduleDrawRef = useRef<() => void>(() => {});\n\n  const [viewport, setViewport] = useState<{ w: number; h: number }>({ w: 0, h: 0 });\n\n  const [interactionDialog, setInteractionDialog] = useState<{\n    open: boolean;\n    content: ReactNode | null;\n  }>({ open: false, content: null });\n\n  const [updateDialog, setUpdateDialog] = useState<{\n    open: boolean;\n    pointer: string;\n    node: ViewerNode | null;\n  }>({ open: false, pointer: '', node: null });\n\n  const [addDialog, setAddDialog] = useState<{\n    open: boolean;\n    pointer: string;\n    node: ViewerNode | null;\n  }>({ open: false, pointer: '', node: null });\n\n  const normalizeCssColor = (c?: string, opacity?: number) => {\n    if (!c) return undefined;\n    const s = c.trim();\n    if ((s.startsWith('\"') && s.endsWith('\"')) || (s.startsWith(\"'\") && s.endsWith(\"'\"))) return s.slice(1, -1);\n    return s + (opacity !== undefined ? `${opacity.toString(16).toUpperCase()}` : '');\n  };\n\n  const pointerToSegments = (p: string): string[] => {\n    if (!p) return [];\n    const s = p.startsWith('/') ? p.slice(1) : p;\n    if (!s) return [];\n    return s.split('/').map(seg => seg.replaceAll('~1', '/').replaceAll('~0', '~'));\n  };\n\n  const relativeSegmentsFromBase = (fullPointer: string): string[] | null => {\n    const base = props.pointer || '';\n    const baseSeg = pointerToSegments(base);\n    const fullSeg = pointerToSegments(fullPointer);\n    for (let i = 0; i < baseSeg.length; i++) {\n      if (baseSeg[i] !== fullSeg[i]) return null;\n    }\n    return fullSeg.slice(baseSeg.length);\n  };\n\n  const updateValueAtPath = (root: unknown, segs: string[], updater: (cur: unknown) => unknown): unknown => {\n    if (segs.length === 0) return updater(root);\n    const [head, ...rest] = segs;\n    if (Array.isArray(root)) {\n      const idx = Number(head);\n      if (!Number.isFinite(idx) || idx < 0 || idx >= root.length) return root;\n      const nextChild = updateValueAtPath(root[idx], rest, updater);\n      if (nextChild === root[idx]) return root;\n      const copy = root.slice();\n      copy[idx] = nextChild;\n      return copy;\n    }\n    if (root !== null && typeof root === 'object') {\n      const obj = root as Record<string, unknown>;\n      const nextChild = updateValueAtPath(obj[head], rest, updater);\n      if (nextChild === obj[head]) return root;\n      // Preserve insertion order for existing keys (InnerViewer keeps the original order when updating values).\n      if (!Object.prototype.hasOwnProperty.call(obj, head)) {\n        return { ...obj, [head]: nextChild };\n      }\n      const entries = Object.entries(obj).map(([k, v]) => (k === head ? [k, nextChild] : [k, v]));\n      return Object.fromEntries(entries);\n    }\n    return root;\n  };\n\n  const applyUpdateValue = (fullPointer: string, value: unknown) => {\n    const rel = relativeSegmentsFromBase(fullPointer);\n    if (!rel) return;\n    const nextRoot = updateValueAtPath(node.data, rel, () => value);\n    onValueChange(nextRoot);\n  };\n\n  const applyDelete = (fullPointer: string) => {\n    const rel = relativeSegmentsFromBase(fullPointer);\n    if (!rel || rel.length === 0) return; // root can't be removed (matches InnerViewer)\n    const parentSegs = rel.slice(0, -1);\n    const last = rel[rel.length - 1];\n    const nextRoot = updateValueAtPath(node.data, parentSegs, parent => {\n      if (Array.isArray(parent)) {\n        const idx = Number(last);\n        if (!Number.isFinite(idx) || idx < 0 || idx >= parent.length) return parent;\n        return parent.filter((_, i) => i !== idx);\n      }\n      if (parent !== null && typeof parent === 'object') {\n        const obj = parent as Record<string, unknown>;\n        const entries = Object.entries(obj).filter(([k]) => k !== last);\n        return Object.fromEntries(entries);\n      }\n      return parent;\n    });\n    onValueChange(nextRoot);\n  };\n\n  const applyAdd = (fullPointer: string, key: string, value: unknown) => {\n    const rel = relativeSegmentsFromBase(fullPointer);\n    if (!rel) return;\n    const nextRoot = updateValueAtPath(node.data, rel, container => {\n      if (Array.isArray(container)) return [...container, value];\n      if (container !== null && typeof container === 'object') {\n        const obj = container as Record<string, unknown>;\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          const entries = Object.entries(obj).map(([k, v]) => (k === key ? [k, value] : [k, v]));\n          return Object.fromEntries(entries);\n        }\n        return { ...obj, [key]: value };\n      }\n      return container;\n    });\n    onValueChange(nextRoot);\n  };\n\n  const applyMove = (fullPointer: string, n: ViewerNode, dir: 'up' | 'down') => {\n    const rel = relativeSegmentsFromBase(fullPointer);\n    if (!rel || rel.length === 0) return;\n    const parentSegs = rel.slice(0, -1);\n    const last = rel[rel.length - 1];\n    const idxHint = n.collapsedIndex;\n    const nextRoot = updateValueAtPath(node.data, parentSegs, parent => {\n      if (Array.isArray(parent)) {\n        const idx = Number(last);\n        const other = dir === 'up' ? idx - 1 : idx + 1;\n        if (!Number.isFinite(idx) || idx < 0 || idx >= parent.length) return parent;\n        if (other < 0 || other >= parent.length) return parent;\n        const copy = parent.slice();\n        const tmp = copy[idx];\n        copy[idx] = copy[other];\n        copy[other] = tmp;\n        return copy;\n      }\n      if (parent !== null && typeof parent === 'object') {\n        const entries = Object.entries(parent as Record<string, unknown>);\n        const idx = typeof idxHint === 'number' ? idxHint : entries.findIndex(([k]) => k === last);\n        if (idx < 0) return parent;\n        const other = dir === 'up' ? idx - 1 : idx + 1;\n        if (idx < 0 || idx >= entries.length) return parent;\n        if (other < 0 || other >= entries.length) return parent;\n        const copy = entries.slice();\n        const tmp = copy[idx];\n        copy[idx] = copy[other];\n        copy[other] = tmp;\n        return Object.fromEntries(copy);\n      }\n      return parent;\n    });\n    onValueChange(nextRoot);\n  };\n\n  const getInteraction = (n: ViewerNode, pointer: string) => {\n    const iProps = { data: n.data, depth: n.depth, config, onDataChange: onValueChange, pointer };\n    const custom = config?.additionalInteraction?.(iProps);\n    if (custom?.highPriority) return custom;\n    return defaultInteraction(iProps) || custom;\n  };\n\n  const { rows, guides, contentHeight, contentWidth } = useMemo(() => {\n    const fontSize = 14;\n    const lineHeight = 20;\n    const topPadding = 16;\n    const bottomPadding = 16;\n    const indentPx = 32;\n    const textOffsetX = 32;\n\n    const measureCanvas = document.createElement('canvas');\n    const mctx = measureCanvas.getContext('2d');\n    if (!mctx) {\n      return {\n        rows: [] as CanvasRow[],\n        guides: [] as { x: number; start: number; end: number; color?: string }[],\n        contentHeight: 0,\n        contentWidth: 0,\n      };\n    }\n    mctx.font = `${fontSize}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace`;\n\n    const nextRows: CanvasRow[] = [];\n    const nextGuides: { x: number; start: number; end: number; color?: string }[] = [];\n    let maxW = 0;\n\n    const measureContentWidth = (contents: ViewerContent[]) => {\n      let w = 0;\n      for (const c of contents) {\n        if (c.type === ViewerContentTypeInteraction) {\n          // Reserve a little width for icons.\n          w += 72;\n        } else {\n          w += mctx.measureText(c.content).width;\n        }\n      }\n      return w;\n    };\n\n    const walk = (n: ViewerNode, pointer: string, depth: number) => {\n      const rowCollapsed = collapsedSet.has(pointer);\n      nextRows.push({ kind: 'before', node: n, pointer, depth, collapsed: rowCollapsed });\n\n      // Approx width: before + (collapsed count?) + (after inline?) + indent\n      const baseX = textOffsetX + depth * indentPx;\n      const beforeW = measureContentWidth(n.before);\n      const countW =\n        rowCollapsed && n.length > 0 ? mctx.measureText(`${n.length} item${n.length > 1 ? 's' : ''}`).width + 24 : 0;\n      const afterInlineW = rowCollapsed || n.children.length === 0 ? measureContentWidth(n.after) : 0;\n      maxW = Math.max(maxW, baseX + beforeW + countW + afterInlineW + 32);\n\n      if (!rowCollapsed && n.children.length > 0) {\n        const childStart = nextRows.length;\n        n.children.forEach((child, index) => {\n          const childPointer =\n            pointer +\n            (child.key ? `/${child.key.replaceAll('~', '~0').replaceAll('/', '~1')}` : `/${index.toString()}`);\n          walk(child, childPointer, depth + 1);\n        });\n        const childEnd = nextRows.length - 1;\n        if (childEnd >= childStart) {\n          nextGuides.push({\n            x: textOffsetX + depth * indentPx,\n            start: childStart,\n            end: childEnd,\n            color: normalizeCssColor(themeInfo.colors?.['editor.foreground']),\n          });\n        }\n        nextRows.push({ kind: 'after', node: n, pointer, depth });\n\n        const afterW = measureContentWidth(n.after);\n        maxW = Math.max(maxW, baseX + afterW + 32);\n      }\n    };\n\n    walk(node, props.pointer, 0);\n    const h = topPadding + nextRows.length * lineHeight + bottomPadding;\n    return {\n      rows: nextRows,\n      guides: nextGuides,\n      contentHeight: h,\n      contentWidth: Math.max(1, maxW),\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [node, props.pointer, collapsedSet, themeInfo]);\n\n  const scheduleDraw = () => {\n    if (rafRef.current !== null) return;\n    rafRef.current = window.requestAnimationFrame(() => {\n      rafRef.current = null;\n      const canvas = canvasRef.current;\n      const scroller = scrollRef.current;\n      if (!canvas || !scroller) return;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) return;\n\n      const dpr = window.devicePixelRatio || 1;\n      const vw = Math.max(1, scroller.clientWidth);\n      const vh = Math.max(1, scroller.clientHeight);\n      if (canvas.width !== Math.floor(vw * dpr) || canvas.height !== Math.floor(vh * dpr)) {\n        canvas.width = Math.floor(vw * dpr);\n        canvas.height = Math.floor(vh * dpr);\n        canvas.style.width = `${vw}px`;\n        canvas.style.height = `${vh}px`;\n      }\n      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\n      const fontSize = 14;\n      const lineHeight = 20;\n      const topPadding = 16;\n      const indentPx = 32;\n      const triangleOffsetX = 16;\n      const textOffsetX = 32;\n      const iconSize = 12;\n      const iconGap = 4;\n\n      ctx.clearRect(0, 0, vw, vh);\n      ctx.fillStyle = normalizeCssColor(bgColor) || '#ffffff';\n      ctx.fillRect(0, 0, vw, vh);\n\n      ctx.font = `${fontSize}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace`;\n      ctx.textBaseline = 'alphabetic';\n      const metrics = ctx.measureText('M');\n      const ascent = metrics.actualBoundingBoxAscent || Math.round(fontSize * 0.8);\n      const baseLineOffsetY = Math.round((lineHeight - fontSize) / 2) + ascent;\n\n      const scrollTop = scroller.scrollTop;\n      const scrollLeft = scroller.scrollLeft;\n\n      // Draw guide lines (border-l dotted)\n      ctx.save();\n      ctx.strokeStyle =\n        normalizeCssColor(themeInfo.colors?.['editor.foreground']) || normalizeCssColor(fgColor) || '#666';\n      ctx.lineWidth = 1;\n      ctx.setLineDash([1, 3]);\n      for (const g of guides) {\n        const y1 = topPadding + g.start * lineHeight - scrollTop;\n        const y2 = topPadding + (g.end + 1) * lineHeight - scrollTop;\n        if (y2 < 0 || y1 > vh) continue;\n        const x = g.x - scrollLeft;\n        ctx.beginPath();\n        ctx.moveTo(x + 0.5, Math.max(0, y1));\n        ctx.lineTo(x + 0.5, Math.min(vh, y2));\n        ctx.stroke();\n      }\n      ctx.restore();\n\n      const startRow = Math.max(0, Math.floor((scrollTop - topPadding) / lineHeight) - 2);\n      const endRow = Math.min(rows.length, Math.ceil((scrollTop - topPadding + vh) / lineHeight) + 2);\n\n      const nextHitRegions: CanvasHitRegion[] = [];\n\n      const hovered = hoverRef.current;\n      const isHovered = (type: CanvasHitType, pointer: string) => hovered?.type === type && hovered.pointer === pointer;\n\n      const drawIcon = (x: number, y: number, kind: CanvasHitType, pointer: string) => {\n        const cx = x + iconSize / 2;\n        const cy = y + lineHeight / 2 - 2;\n        const stroke = normalizeCssColor(themeInfo.colors?.['button.background'], 178) || '#999';\n        const hoverStroke =\n          normalizeCssColor(themeInfo.colors?.['button.hoverBackground']) ||\n          normalizeCssColor(themeInfo.colors?.['button.background']) ||\n          '#bbb';\n        const color = isHovered(kind, pointer) ? hoverStroke : stroke;\n\n        ctx.save();\n        ctx.strokeStyle = color;\n        ctx.fillStyle = color;\n        ctx.lineWidth = 1.2;\n\n        if (kind === 'interaction') {\n          ctx.beginPath();\n          ctx.arc(cx, cy, 5, 0, Math.PI * 2);\n          ctx.fill();\n        } else {\n          ctx.beginPath();\n          ctx.arc(cx, cy, 5, 0, Math.PI * 2);\n          ctx.stroke();\n          ctx.lineWidth = 1;\n          const s = 2.5;\n          if (kind === 'edit-add') {\n            ctx.beginPath();\n            ctx.moveTo(cx - s, cy);\n            ctx.lineTo(cx + s, cy);\n            ctx.moveTo(cx, cy - s);\n            ctx.lineTo(cx, cy + s);\n            ctx.stroke();\n          } else if (kind === 'edit-delete') {\n            ctx.beginPath();\n            ctx.moveTo(cx - s, cy);\n            ctx.lineTo(cx + s, cy);\n            ctx.stroke();\n          } else if (kind === 'edit-update') {\n            // up arrow\n            ctx.beginPath();\n            ctx.moveTo(cx, cy + s);\n            ctx.lineTo(cx, cy - s);\n            ctx.lineTo(cx - s, cy - s + 2);\n            ctx.moveTo(cx, cy - s);\n            ctx.lineTo(cx + s, cy - s + 2);\n            ctx.stroke();\n          } else if (kind === 'edit-move-up') {\n            ctx.beginPath();\n            ctx.moveTo(cx, cy + s);\n            ctx.lineTo(cx, cy - s);\n            ctx.lineTo(cx - s, cy - s + 2);\n            ctx.moveTo(cx, cy - s);\n            ctx.lineTo(cx + s, cy - s + 2);\n            ctx.stroke();\n          } else if (kind === 'edit-move-down') {\n            ctx.beginPath();\n            ctx.moveTo(cx, cy - s);\n            ctx.lineTo(cx, cy + s);\n            ctx.lineTo(cx - s, cy + s - 2);\n            ctx.moveTo(cx, cy + s);\n            ctx.lineTo(cx + s, cy + s - 2);\n            ctx.stroke();\n          }\n        }\n        ctx.restore();\n      };\n\n      const drawContents = (\n        x0: number,\n        y0: number,\n        contents: ViewerContent[],\n        pointer: string,\n        n: ViewerNode,\n        allowCollapse: boolean,\n      ) => {\n        let x = x0;\n        const canCollapse = allowCollapse && n.length > 0;\n        let keyStart: number | null = null;\n        let keyEnd: number | null = null;\n\n        const maybePushKeyRegion = (rowY: number) => {\n          if (keyStart !== null && keyEnd !== null && canCollapse) {\n            nextHitRegions.push({\n              type: 'toggle-key',\n              pointer,\n              node: n,\n              rect: { x: keyStart, y: rowY, w: keyEnd - keyStart, h: lineHeight },\n            });\n          }\n        };\n\n        for (const item of contents) {\n          if (item.type === ViewerContentTypeInteraction) {\n            // Draw interaction icons at the insertion point.\n            if (mode === 'normal') {\n              const interaction = getInteraction(n, pointer);\n              if (interaction) {\n                const iconX = x;\n                drawIcon(iconX - scrollLeft, y0, 'interaction', pointer);\n                nextHitRegions.push({\n                  type: 'interaction',\n                  pointer,\n                  node: n,\n                  rect: { x: iconX - scrollLeft, y: y0, w: iconSize, h: lineHeight },\n                });\n                x += iconSize + iconGap;\n              }\n            } else if (mode === 'edit' && !config?.uneditable) {\n              const icons: CanvasHitType[] = [];\n              const openMove = config?.openMove;\n              const isObj = n.data !== null && typeof n.data === 'object';\n              if (n.depth === 0) {\n                if (isObj) icons.push('edit-add');\n                icons.push('edit-update');\n              } else {\n                if (isObj) icons.push('edit-add');\n                icons.push('edit-delete', 'edit-update');\n                if (openMove && n.collapsedIndex !== 0) icons.push('edit-move-up');\n                if (openMove && n.collapsedIndex !== undefined && n.collapsedIndex + 1 !== n.collapsedLength)\n                  icons.push('edit-move-down');\n              }\n              for (const kind of icons) {\n                const iconX = x;\n                drawIcon(iconX - scrollLeft, y0, kind, pointer);\n                nextHitRegions.push({\n                  type: kind,\n                  pointer,\n                  node: n,\n                  rect: { x: iconX - scrollLeft, y: y0, w: iconSize, h: lineHeight },\n                });\n                x += iconSize + iconGap;\n              }\n            }\n            continue;\n          }\n\n          const text = item.content;\n          const w = ctx.measureText(text).width;\n          const bg = normalizeCssColor(item.bgColor);\n          if (bg) {\n            ctx.fillStyle = bg;\n            ctx.fillRect(x - scrollLeft, y0, w, lineHeight);\n          }\n          ctx.fillStyle = normalizeCssColor(item.color) || normalizeCssColor(fgColor) || '#111';\n          ctx.fillText(text, x - scrollLeft, y0 + baseLineOffsetY);\n\n          if (item.type === ViewerContentTypeKey) {\n            if (keyStart === null) keyStart = x - scrollLeft;\n            keyEnd = x - scrollLeft + w;\n          } else {\n            maybePushKeyRegion(y0);\n            keyStart = null;\n            keyEnd = null;\n          }\n          x += w;\n        }\n\n        maybePushKeyRegion(y0);\n        return x;\n      };\n\n      for (let i = startRow; i < endRow; i++) {\n        const row = rows[i];\n        const y = topPadding + i * lineHeight - scrollTop;\n        if (y + lineHeight < 0 || y > vh) continue;\n\n        if (row.kind === 'before') {\n          const n = row.node;\n          const pointer = row.pointer;\n\n          // triangle toggle\n          if (n.length > 0) {\n            const tx = triangleOffsetX + row.depth * indentPx - scrollLeft;\n            const ty = y;\n            const hoverColor =\n              normalizeCssColor(themeInfo.colors?.['button.hoverBackground']) ||\n              normalizeCssColor(themeInfo.colors?.['button.background']) ||\n              '#bbb';\n            const baseColor = normalizeCssColor(themeInfo.colors?.['button.background'], 178) || '#999';\n            ctx.fillStyle = isHovered('toggle-triangle', pointer) ? hoverColor : baseColor;\n            ctx.save();\n            ctx.font = `${fontSize + 2}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace`;\n            ctx.fillText(row.collapsed ? '▶' : '▼', tx, y + baseLineOffsetY - 1);\n            ctx.restore();\n            nextHitRegions.push({\n              type: 'toggle-triangle',\n              pointer,\n              node: n,\n              rect: { x: tx, y: ty, w: 18, h: lineHeight },\n            });\n          }\n\n          const x0 = textOffsetX + row.depth * indentPx;\n          let x = drawContents(x0, y, n.before, pointer, n, true);\n\n          if (row.collapsed) {\n            const countText = `${n.length} item${n.length > 1 ? 's' : ''}`;\n            const cw = ctx.measureText(countText).width;\n            const pad = 12;\n            const countX = x + pad;\n            const countColor =\n              normalizeCssColor(themeInfo.fg) ||\n              normalizeCssColor(themeInfo.colors?.['editor.foreground']) ||\n              normalizeCssColor(fgColor) ||\n              '#111';\n            ctx.fillStyle = countColor;\n            ctx.fillText(countText, countX - scrollLeft, y + baseLineOffsetY);\n            if (isHovered('toggle-collapsed-count', pointer)) {\n              ctx.beginPath();\n              ctx.strokeStyle = countColor;\n              ctx.moveTo(countX - scrollLeft, y + baseLineOffsetY + 2);\n              ctx.lineTo(countX - scrollLeft + cw, y + baseLineOffsetY + 2);\n              ctx.stroke();\n            }\n            nextHitRegions.push({\n              type: 'toggle-collapsed-count',\n              pointer,\n              node: n,\n              rect: { x: countX - scrollLeft, y, w: cw, h: lineHeight },\n            });\n            x = countX + cw + pad;\n          }\n\n          // Inline after when collapsed or leaf\n          if (row.collapsed || n.children.length === 0) {\n            drawContents(x, y, n.after, pointer, n, false);\n          }\n        } else {\n          const n = row.node;\n          const pointer = row.pointer;\n          const x0 = textOffsetX + row.depth * indentPx;\n          drawContents(x0, y, n.after, pointer, n, false);\n        }\n      }\n\n      hitRegionsRef.current = nextHitRegions;\n    });\n  };\n\n  // 避免 scroll/resize listener 捕获旧的 scheduleDraw（否则折叠状态会在滚动后“恢复”）。\n  scheduleDrawRef.current = scheduleDraw;\n\n  useEffect(() => {\n    const scroller = scrollRef.current;\n    if (!scroller) return;\n    const onScroll = () => scheduleDrawRef.current();\n    scroller.addEventListener('scroll', onScroll, { passive: true });\n    const ro = new ResizeObserver(() => {\n      setViewport({ w: scroller.clientWidth, h: scroller.clientHeight });\n      scheduleDrawRef.current();\n    });\n    ro.observe(scroller);\n    setViewport({ w: scroller.clientWidth, h: scroller.clientHeight });\n    scheduleDrawRef.current();\n    return () => {\n      scroller.removeEventListener('scroll', onScroll);\n      ro.disconnect();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    scheduleDraw();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [rows, guides, bgColor, fgColor, mode, config?.openMove, config?.uneditable]);\n\n  const findHit = (x: number, y: number) => {\n    const hits = hitRegionsRef.current;\n    for (let i = hits.length - 1; i >= 0; i--) {\n      const r = hits[i].rect;\n      if (x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h) return hits[i];\n    }\n    return null;\n  };\n\n  const onMouseMove: MouseEventHandler<HTMLCanvasElement> = e => {\n    const hit = findHit(e.nativeEvent.offsetX, e.nativeEvent.offsetY);\n    const nextHover = hit ? { type: hit.type, pointer: hit.pointer } : null;\n    const prev = hoverRef.current;\n    const changed = prev?.type !== nextHover?.type || prev?.pointer !== nextHover?.pointer;\n    if (changed) {\n      hoverRef.current = nextHover;\n      const canvas = canvasRef.current;\n      if (canvas) {\n        canvas.style.cursor = hit ? 'pointer' : 'default';\n      }\n      scheduleDraw();\n    }\n  };\n\n  const onMouseLeave: MouseEventHandler<HTMLCanvasElement> = () => {\n    if (hoverRef.current) {\n      hoverRef.current = null;\n      const canvas = canvasRef.current;\n      if (canvas) canvas.style.cursor = 'default';\n      scheduleDraw();\n    }\n  };\n\n  const onClick: MouseEventHandler<HTMLCanvasElement> = e => {\n    const hit = findHit(e.nativeEvent.offsetX, e.nativeEvent.offsetY);\n    if (!hit) return;\n    const pointer = hit.pointer;\n    const n = hit.node;\n    switch (hit.type) {\n      case 'toggle-triangle':\n      case 'toggle-key':\n      case 'toggle-collapsed-count':\n        // 任意层级折叠：pointer 唯一标识节点。\n        if (n.length > 0) {\n          setCollapsedSet(prev => {\n            const next = new Set(prev);\n            if (hit.type === 'toggle-collapsed-count') {\n              next.delete(pointer);\n            } else {\n              next.has(pointer) ? next.delete(pointer) : next.add(pointer);\n            }\n            return next;\n          });\n        }\n        break;\n      case 'interaction': {\n        const interaction = getInteraction(n, pointer);\n        if (!interaction?.event) return;\n        if (typeof interaction.event === 'function') {\n          interaction.event(e.nativeEvent);\n        } else {\n          setInteractionDialog({ open: true, content: interaction.event });\n        }\n        break;\n      }\n      case 'edit-add':\n        setAddDialog({ open: true, pointer, node: n });\n        break;\n      case 'edit-update':\n        setUpdateDialog({ open: true, pointer, node: n });\n        break;\n      case 'edit-delete':\n        applyDelete(pointer);\n        break;\n      case 'edit-move-up':\n        applyMove(pointer, n, 'up');\n        break;\n      case 'edit-move-down':\n        applyMove(pointer, n, 'down');\n        break;\n    }\n  };\n\n  // The canvas renderer virtualizes all text; dialogs are still regular React UI.\n  return (\n    <>\n      <div\n        ref={scrollRef}\n        className={cn(\n          props.className,\n          // Keep these in sync with InnerViewer's PreWrapper, but padding is handled in canvas drawing.\n          'scrollbar-thin text-sm font-mono font-normal antialiased',\n        )}\n        style={{ backgroundColor: bgColor, color: fgColor }}\n      >\n        <canvas\n          ref={canvasRef}\n          className=\"sticky top-0 left-0 block w-full\"\n          style={{ backgroundColor: bgColor }}\n          onMouseMove={onMouseMove}\n          onMouseLeave={onMouseLeave}\n          onClick={onClick}\n        />\n        <div style={{ height: Math.max(0, contentHeight - viewport.h), width: contentWidth }} />\n      </div>\n\n      <Dialog open={interactionDialog.open} onOpenChange={open => setInteractionDialog(s => ({ ...s, open }))}>\n        {interactionDialog.content ? (\n          <DialogContent\n            showCloseButton={false}\n            autoFocus={false}\n            onOpenAutoFocus={e => e.preventDefault()}\n            className=\"w-full max-w-[80vw]!\"\n            aria-describedby={undefined}\n          >\n            <VisuallyHidden asChild>\n              <DialogTitle />\n            </VisuallyHidden>\n            {interactionDialog.content}\n          </DialogContent>\n        ) : null}\n      </Dialog>\n\n      <Dialog open={updateDialog.open} onOpenChange={open => setUpdateDialog(s => ({ ...s, open }))}>\n        {updateDialog.node ? (\n          <UpdateValueDialogContent\n            isArray={!updateDialog.node.key}\n            config={config}\n            defaultKey={updateDialog.node.key}\n            defaultValue={JSONHandler.stringify(updateDialog.node.data, null, 2)}\n            onSubmitValue={(_, v) => {\n              applyUpdateValue(updateDialog.pointer, v);\n              setUpdateDialog(s => ({ ...s, open: false }));\n            }}\n          />\n        ) : null}\n      </Dialog>\n\n      <Dialog open={addDialog.open} onOpenChange={open => setAddDialog(s => ({ ...s, open }))}>\n        {addDialog.node ? (\n          <UpdateValueDialogContent\n            isArray={Array.isArray(addDialog.node.data)}\n            config={config}\n            onSubmitValue={(k, v) => {\n              if (Array.isArray(addDialog.node!.data)) {\n                applyAdd(addDialog.pointer, '', v);\n              } else {\n                applyAdd(addDialog.pointer, k, v);\n              }\n              setAddDialog(s => ({ ...s, open: false }));\n            }}\n          />\n        ) : null}\n      </Dialog>\n    </>\n  );\n}\n\n// 计算层级和颜色\nconst ViewerContentTypeNormal = 0 as const;\nconst ViewerContentTypeKey = 1 as const;\nconst ViewerContentTypeInteraction = 2 as const;\ntype ViewerContentType =\n  | typeof ViewerContentTypeNormal\n  | typeof ViewerContentTypeKey\n  | typeof ViewerContentTypeInteraction;\n\ninterface ViewerContent {\n  content: string;\n  color?: string;\n  bgColor?: string;\n  type: ViewerContentType;\n}\n\ninterface ViewerNode {\n  key?: string;\n  data: unknown;\n  length: number;\n  depth: number;\n  collapsedIndex?: number;\n  collapsedLength?: number;\n  before: ViewerContent[];\n  children: ViewerNode[];\n  after: ViewerContent[];\n}\n\nfunction calcDfs(props: {\n  data: unknown;\n  color: (string | undefined)[];\n  from: number;\n  depth: number;\n  key?: string;\n  collapsedIndex?: number;\n  collapsedLength?: number;\n  highlightPointer?: string[]; // 保证已排序\n  highlightColor: string;\n  pointer: string;\n}): [ViewerNode, number] {\n  const { data, color, from, depth, key, collapsedIndex, collapsedLength, highlightPointer, highlightColor } = props;\n  const length = collapseLength(data);\n  const node: ViewerNode = {\n    key,\n    data,\n    length,\n    depth,\n    collapsedIndex,\n    collapsedLength,\n    before: [],\n    children: [],\n    after: [],\n  };\n  let dfsIndex = from;\n  const highlightType: 'none' | 'partial' | 'all' = (() => {\n    if (highlightPointer && highlightPointer.length > 0) {\n      let left = 0,\n        right = highlightPointer.length - 1;\n      while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (props.pointer === highlightPointer[mid]) {\n          return 'partial';\n        } else if (props.pointer.startsWith(highlightPointer[mid])) {\n          return 'all';\n        } else if (highlightPointer[mid] < props.pointer) {\n          left = mid + 1;\n        } else {\n          right = mid - 1;\n        }\n      }\n    }\n    return 'none';\n  })();\n  const toViewerContent = (s: string, type?: ViewerContentType) => {\n    const current: ViewerContent[] = [];\n    const bgColor =\n      highlightType === 'all' || (highlightType === 'partial' && type !== ViewerContentTypeKey)\n        ? highlightColor\n        : undefined;\n    for (const c of s) {\n      const lastColor = current?.[current.length - 1]?.color;\n      const lastBgColor = current?.[current.length - 1]?.bgColor;\n      const currentColor = color?.[dfsIndex];\n      if (lastColor === currentColor && lastBgColor === bgColor) {\n        current[current.length - 1].content += c;\n      } else {\n        current.push({ content: c, color: currentColor, bgColor, type: type || ViewerContentTypeNormal });\n      }\n      dfsIndex++;\n    }\n    return current;\n  };\n  if (key !== undefined) {\n    const current = toViewerContent(JSONHandler.stringify(key), ViewerContentTypeKey);\n    node.before.push(...current, {\n      content: ': ',\n      color: color?.[dfsIndex],\n      type: ViewerContentTypeNormal,\n      bgColor: highlightType === 'all' ? highlightColor : undefined,\n    });\n    dfsIndex++;\n  }\n  node.before.push({ content: '', type: ViewerContentTypeInteraction });\n  if (typeof data === 'string') {\n    node.before.push(...toViewerContent(JSONHandler.stringify(data)));\n  } else if (typeof data === 'number' || typeof data === 'bigint' || typeof data === 'boolean' || data === null) {\n    const text = data === null ? 'null' : data.toString();\n    node.before.push(...toViewerContent(text));\n  } else if (data instanceof Array) {\n    if (length > 0) {\n      node.before.push(...toViewerContent('['));\n      for (let i = 0; i < length; i++) {\n        const [child, newDfsIndex] = calcDfs({\n          data: data[i],\n          color,\n          from: dfsIndex,\n          depth: depth + 1,\n          collapsedIndex: i,\n          collapsedLength: length,\n          highlightPointer,\n          highlightColor,\n          pointer: props.pointer + `/${i}`,\n        });\n        node.children.push(child);\n        dfsIndex = newDfsIndex;\n      }\n      node.after.push(...toViewerContent(']'));\n    } else {\n      node.before.push(...toViewerContent('[]'));\n    }\n  } else if (typeof data === 'object') {\n    if (length > 0) {\n      node.before.push(...toViewerContent('{'));\n      Object.entries(data).forEach(([key, son], i) => {\n        const [child, newDfsIndex] = calcDfs({\n          data: son,\n          color,\n          from: dfsIndex,\n          depth: depth + 1,\n          key,\n          collapsedIndex: i,\n          collapsedLength: length,\n          highlightPointer,\n          highlightColor,\n          pointer: props.pointer + `/${key.replaceAll('~', '~0').replaceAll('/', '~1')}`,\n        });\n        node.children.push(child);\n        dfsIndex = newDfsIndex;\n      });\n      node.after.push(...toViewerContent('}'));\n    } else {\n      node.before.push(...toViewerContent('{}'));\n    }\n  }\n  if (collapsedIndex !== undefined && collapsedIndex + 1 !== collapsedLength) {\n    node.after.push({\n      content: ',',\n      color: color?.[dfsIndex],\n      type: ViewerContentTypeNormal,\n      bgColor: highlightType === 'all' ? highlightColor : undefined,\n    });\n    dfsIndex++;\n  }\n\n  return [node, dfsIndex];\n}\n\nfunction calc(\n  data: unknown,\n  t: TokensResult,\n  highlightPointer: string[] | undefined,\n  highlightColor: string,\n): ViewerNode {\n  const color: (string | undefined)[] = [];\n  for (const t1 of t.tokens) {\n    for (const t2 of t1) {\n      for (const _ of t2.content) {\n        color.push(t2.color);\n      }\n    }\n  }\n  return calcDfs({ data, color, from: 0, depth: 0, highlightPointer, highlightColor, pointer: '' })[0];\n}\n\nfunction JsonPathDialogContent({\n  source,\n  config,\n  pointer,\n}: {\n  source: unknown;\n  config?: DataViewerConfig;\n  pointer: string;\n}) {\n  const [jsonPath, setJsonPath] = useState('$');\n  const json = useMemo(() => JSONHandler.stringify(source), [source]);\n  const result: string | { value: unknown; pointer: string }[] = useMemo(() => {\n    try {\n      return JSONPath({ path: jsonPath || '$', json: source!, resultType: 'all', wrap: true, ignoreEvalErrors: true });\n    } catch (e) {\n      return `${e}`;\n    }\n  }, [jsonPath, json]);\n  const dataViewerConfig = {\n    ...config,\n    uneditable: true,\n    withoutMaximize: true,\n    withToaster: false,\n    withThemeChange: false,\n  };\n  return (\n    <DialogContent\n      showCloseButton={false}\n      autoFocus={false}\n      onOpenAutoFocus={e => e.preventDefault()}\n      className=\"w-full max-w-[80vw]! max-h-[80vh]\"\n      aria-describedby={undefined}\n    >\n      <VisuallyHidden asChild>\n        <DialogTitle />\n      </VisuallyHidden>\n      <div className=\"w-[calc(80vw-3rem)]\">\n        <InputGroup>\n          <InputGroupInput placeholder=\"$\" value={jsonPath} onChange={e => setJsonPath(e.target.value)} />\n          <InputGroupAddon align=\"inline-end\">\n            <Tooltip>\n              <TooltipTrigger>\n                <InputGroupButton\n                  className=\"rounded-full cursor-pointer\"\n                  size=\"icon-xs\"\n                  onClick={() => {\n                    window.open('https://github.com/JSONPath-Plus/JSONPath/blob/main/README.md', '_blank');\n                  }}\n                >\n                  <CircleQuestionMark />\n                </InputGroupButton>\n              </TooltipTrigger>\n              <TooltipContent>规则详情</TooltipContent>\n            </Tooltip>\n          </InputGroupAddon>\n        </InputGroup>\n      </div>\n      <div className=\"flex gap-4 w-full\">\n        <div className=\"w-[calc((80vw-4rem)/3)]\">\n          <DataViewerIntl\n            data={json}\n            config={dataViewerConfig}\n            className=\"rounded-md\"\n            preClassName=\"rounded-md border-2 max-h-[calc(80vh-8rem)]\"\n            pointer={pointer}\n            highlightPointer={\n              typeof result !== 'string'\n                ? result?.map(item => item.pointer)?.sort((a, b) => (a < b ? -1 : a == b ? 0 : 1))\n                : undefined\n            }\n          />\n        </div>\n        <div className=\"w-[calc((80vw-4rem)/3*2)]\">\n          {typeof result === 'string' ? (\n            <div\n              className=\"p-4 rounded-md border-2 h-full max-h-[calc(80vh-8rem)] font-mono\"\n              style={{ color: config?.themeInfo?.colors?.['editorError.foreground'] }}\n            >\n              {result}\n            </div>\n          ) : (\n            <DataViewerIntl\n              data={JSONHandler.stringify(result?.map(item => item.value))}\n              config={dataViewerConfig}\n              className=\"rounded-md\"\n              preClassName=\"rounded-md border-2 max-h-[calc(80vh-8rem)]\"\n              pointer=\"\"\n            />\n          )}\n        </div>\n      </div>\n    </DialogContent>\n  );\n}\n\n// 入口组件\ninterface DataViewerConfig {\n  type?: DataType; // 强制制定数据类型 不填则根据数据自动判断\n  themeInfo?: ThemeRegistration; // 默认自定义主题 默认为one-light\n  withoutButtonGroup?: boolean; // 是否不展示操作按钮组\n  withToaster?: boolean; // 是否需要toaster\n  withoutMaximize?: boolean; // 是否不展示最大化按钮\n  showInteractionWithStringLengthGte?: number; // 展示交互的字符串长度阈值 不填则为100\n  additionalInteraction?: Interaction; // 自定义交互逻辑\n  uneditable?: boolean; // 是否可编辑\n  openMove?: boolean; // 默认是否开启移动操作\n  disableLocalStorage?: boolean; // 是否禁用localStorage\n  useShikiJavascriptEngine?: boolean; // 使用shiki javascript引擎\n  useCanvas?: boolean;\n  forceCanvasThreshold?: number; // 强制使用 Canvas 的阈值（字节），默认 102400\n}\n\ninterface DataViewerProps {\n  data: string;\n  className?: string;\n  preClassName?: string;\n  title?: string;\n  onDataChange?: (data: unknown) => void; // 数据编辑回调\n  onThemeInfoChange?: (theme: ThemeRegistration) => void; // 默认主题切换回调\n  onCloseButtonGroup?: (e: MouseEvent) => void; // 关闭工具栏回调\n  onOpenMoveChange?: (openMove: boolean) => void; // 移动操作展开状态改变回调\n  config?: DataViewerConfig;\n}\n\ninterface DataViewerIntlProps extends DataViewerProps {\n  pointer: string; // https://datatracker.ietf.org/doc/html/rfc6901\n  highlightPointer?: string[];\n}\n\nconst localStorageOpenMoveKey = 'conanyu-data-viewer.open-move' as const;\n\nconst globalHighlighter: Map<ThemeRegistration, HighlighterGeneric<string, string>> = new Map();\n\nfunction DataViewerIntl(props: DataViewerIntlProps) {\n  // 处理配置\n  const {\n    type,\n    themeInfo: propThemeInfo,\n    withoutButtonGroup,\n    withoutMaximize,\n    withToaster,\n    uneditable,\n    openMove: propOpenMove,\n    disableLocalStorage,\n    useShikiJavascriptEngine,\n  } = props.config || {};\n  const getThemeInfo = () => {\n    return propThemeInfo ?? (OneLight as ThemeRegistration);\n  };\n  const [themeInfo, setThemeInfo] = useState<ThemeRegistration>(getThemeInfo());\n  useEffect(() => {\n    setThemeInfo(getThemeInfo());\n  }, [propThemeInfo]);\n  const [withButtonGroup, setWithButtonGroup] = useState(!withoutButtonGroup);\n  const [source, setSource] = useState(props.data);\n  useEffect(() => {\n    setSource(props.data);\n  }, [props.data]);\n\n  const shouldForceCanvas = useMemo(() => {\n    const forceCanvasThreshold = props.config?.forceCanvasThreshold ?? 102400;\n    const sourceByteLength = (() => {\n      try {\n        return new TextEncoder().encode(source).length;\n      } catch {\n        return source.length;\n      }\n    })();\n    return sourceByteLength > forceCanvasThreshold;\n  }, [source, props.config?.forceCanvasThreshold]);\n\n  const [mode, setMode] = useState<'normal' | 'edit'>('normal');\n  const getOpenMove = () => {\n    return (\n      propOpenMove ??\n      (() => {\n        if (disableLocalStorage) {\n          return null;\n        }\n        const openMove = localStorage.getItem(localStorageOpenMoveKey);\n        return openMove === null ? null : openMove === 'true';\n      })() ??\n      false\n    );\n  };\n  const [openMove, setOpenMove] = useState(getOpenMove());\n  useEffect(() => {\n    setOpenMove(getOpenMove());\n  }, [propOpenMove]);\n  const [jsonPathDialogOpen, setJsonPathDialogOpen] = useState(false);\n\n  // 处理转化逻辑\n  const data = useMemo(() => autoDetect({ data: source, type: type }), [source, type]);\n\n  // 处理样式\n  const [highlighter, setHighlighter] = useState<[HighlighterGeneric<string, string>, ThemeRegistration] | undefined>(\n    undefined,\n  );\n\n  useEffect(() => {\n    const theme = themeInfo;\n    (async () => {\n      const cachedHighlighter = globalHighlighter.get(theme);\n      if (cachedHighlighter) {\n        setHighlighter([cachedHighlighter, theme]);\n      } else {\n        const highlighter = (await createHighlighter(\n          useShikiJavascriptEngine\n            ? { langs: ['json'], themes: [theme], engine: createJavaScriptRegexEngine() }\n            : { langs: ['json'], themes: [theme] },\n        )) as HighlighterGeneric<string, string>;\n        setHighlighter([highlighter, theme]);\n        globalHighlighter.set(theme, highlighter);\n      }\n    })();\n  }, [themeInfo]);\n\n  const [bgColor, fgColor, root] = useMemo(() => {\n    if (!highlighter || data.data === undefined) {\n      return [\n        themeInfo?.bg || themeInfo?.colors?.['editor.background'],\n        themeInfo?.fg || themeInfo?.colors?.['editor.foreground'],\n        undefined,\n      ];\n    }\n    const t = highlighter[0].codeToTokens(JSONHandler.stringify(data.data), { lang: 'json', theme: highlighter[1] });\n    let r: ViewerNode | undefined = undefined;\n    try {\n      r = calc(\n        data.data,\n        t,\n        props.highlightPointer,\n        themeInfo.colors?.['editor.findMatchHighlightBackground'] || '\"#0000000C\"',\n      );\n    } catch (e) {\n      console.error(e);\n      toast.error(`非预期错误：${e}`);\n    }\n    return [t.bg, t.fg, r];\n  }, [data, highlighter, themeInfo, props.highlightPointer]);\n\n  const exhibition = useMemo(() => {\n    const PreWrapper = ({ children }: { children?: ReactNode }) => {\n      return (\n        <pre\n          className={cn(\n            withButtonGroup ? 'overflow-y-scroll' : 'overflow-auto',\n            'scrollbar-thin py-4 text-sm font-mono font-normal antialiased',\n            props.preClassName,\n          )}\n          style={{ backgroundColor: bgColor, color: fgColor }}\n        >\n          {children}\n        </pre>\n      );\n    };\n    if (data.error) {\n      return (\n        <PreWrapper>\n          <div className=\"px-4\" style={{ color: themeInfo.colors?.['editorError.foreground'] }}>\n            {data.error}\n          </div>\n        </PreWrapper>\n      );\n    }\n    if (!root) {\n      return (\n        <PreWrapper>\n          <div className=\"px-4\">\n            <LoaderCircle className=\"animate-spin\" />\n          </div>\n        </PreWrapper>\n      );\n    }\n    const innerViewerProps: InnerViewerProps = {\n      mode,\n      themeInfo,\n      node: root,\n      config: { ...props.config, openMove },\n      onValueChange: value => {\n        setSource(JSONHandler.stringify(value));\n        props.onDataChange?.(value);\n      },\n      pointer: props.pointer,\n    };\n    if (props.config?.useCanvas || shouldForceCanvas) {\n      return (\n        <CanvasInnerViewer\n          {...innerViewerProps}\n          className={cn(\n            withButtonGroup ? 'overflow-y-scroll' : 'overflow-auto',\n            // Match InnerViewer's PreWrapper typography; padding is handled inside CanvasInnerViewer drawing.\n            'scrollbar-thin text-sm font-mono font-normal antialiased',\n            props.preClassName,\n          )}\n        />\n      );\n    } else {\n      return (\n        <PreWrapper>\n          <InnerViewer {...innerViewerProps} />\n        </PreWrapper>\n      );\n    }\n  }, [\n    bgColor,\n    fgColor,\n    root,\n    withButtonGroup,\n    props.preClassName,\n    data,\n    mode,\n    themeInfo,\n    props.config,\n    openMove,\n    shouldForceCanvas,\n  ]);\n\n  return (\n    <>\n      {withToaster && <Toaster />}\n      <div className={cn('relative overflow-auto scrollbar-thin', props.className)}>\n        {exhibition}\n        {withButtonGroup && !data.error && data.data !== undefined && (\n          <div className=\"absolute right-4 top-2\">\n            <ButtonGroup>\n              {props.title && <div className={buttonVariants({ variant: 'outline' })}>{props.title}</div>}\n              <TooltipButton\n                tooltip=\"复制为JSON\"\n                icon={<CopyIcon />}\n                onClick={async () => {\n                  await navigator.clipboard.writeText(JSONHandler.stringify(data.data, null, 2));\n                  toast.success('复制成功');\n                }}\n              />\n              {!withoutMaximize && (\n                <Dialog>\n                  <DialogTrigger asChild>\n                    <TooltipButton tooltip=\"弹窗展示\" icon={<Maximize />} onClick={async () => {}} />\n                  </DialogTrigger>\n                  <DialogContent\n                    showCloseButton={false}\n                    autoFocus={false}\n                    onOpenAutoFocus={e => e.preventDefault()}\n                    className=\"w-full max-w-[80vw]!\"\n                    aria-describedby={undefined}\n                  >\n                    <DataViewerIntl\n                      data={source}\n                      className=\"border-2 rounded-md h-full max-h-[80vh]\"\n                      preClassName=\"h-full\"\n                      onDataChange={value => {\n                        setSource(stringifyPrettyMap[data.type](value));\n                        props.onDataChange?.(value);\n                      }}\n                      config={{ ...props.config, withToaster: false, withoutMaximize: true }}\n                      pointer={props.pointer}\n                    />\n                  </DialogContent>\n                </Dialog>\n              )}\n              {!uneditable && (\n                <TooltipButton\n                  tooltip=\"切换模式\"\n                  icon={mode === 'normal' ? <Sparkle /> : <SquarePen />}\n                  onClick={() => setMode(mode === 'normal' ? 'edit' : 'normal')}\n                />\n              )}\n              <DropdownMenu>\n                <DropdownMenuTrigger\n                  className={buttonVariants({\n                    variant: 'outline',\n                    size: 'icon',\n                    className: 'cursor-pointer bg-white text-gray-600',\n                  })}\n                >\n                  <Ellipsis />\n                </DropdownMenuTrigger>\n                <DropdownMenuContent>\n                  <DropdownMenuLabel>操作</DropdownMenuLabel>\n                  <DropdownMenuGroup>\n                    <DropdownMenuItem\n                      className=\"cursor-pointer\"\n                      onClick={async () => {\n                        await navigator.clipboard.writeText(props.data);\n                        toast.success('复制成功');\n                      }}\n                    >\n                      复制原始内容\n                    </DropdownMenuItem>\n                    <DropdownMenuItem\n                      className=\"cursor-pointer\"\n                      onClick={async () => {\n                        await navigator.clipboard.writeText(JSONHandler.stringify(data.data));\n                        toast.success('复制成功');\n                      }}\n                    >\n                      复制为压缩JSON\n                    </DropdownMenuItem>\n                    <DropdownMenuItem\n                      className=\"cursor-pointer\"\n                      onClick={async () => {\n                        await navigator.clipboard.writeText(JSONHandler.stringify(JSONHandler.stringify(data.data)));\n                        toast.success('复制成功');\n                      }}\n                    >\n                      复制为转义JSON\n                    </DropdownMenuItem>\n                    <DropdownMenuItem\n                      className=\"cursor-pointer\"\n                      onClick={async () => {\n                        await navigator.clipboard.writeText(JSON5.stringify(data.data, null, 2));\n                        toast.success('复制成功');\n                      }}\n                    >\n                      复制为JSON5\n                    </DropdownMenuItem>\n                    <DropdownMenuItem\n                      className=\"cursor-pointer\"\n                      onClick={async () => {\n                        await navigator.clipboard.writeText(\n                          YAML.stringify(data.data, { intAsBigInt: isSupportBigInt, indent: 2 }),\n                        );\n                        toast.success('复制成功');\n                      }}\n                    >\n                      复制为YAML\n                    </DropdownMenuItem>\n                    <DropdownMenuItem\n                      className=\"cursor-pointer\"\n                      onClick={async () => {\n                        const jsonPath =\n                          '$' +\n                          props.pointer\n                            .split('/')\n                            .slice(1)\n                            .map(item => `['${item.replaceAll('~0', '~').replaceAll('~1', '/')}']`)\n                            .join('');\n                        await navigator.clipboard.writeText(jsonPath);\n                        toast.success(`复制成功（${jsonPath}）`);\n                      }}\n                    >\n                      复制JSON Path\n                    </DropdownMenuItem>\n                    {props.pointer.length > 0 && (\n                      <DropdownMenuItem\n                        className=\"cursor-pointer\"\n                        onClick={async () => {\n                          await navigator.clipboard.writeText(props.pointer);\n                          toast.success(`复制成功（${props.pointer}）`);\n                        }}\n                      >\n                        复制JSON Pointer\n                        <DropdownMenuShortcut\n                          className=\"cursor-help\"\n                          onClick={e => {\n                            e.stopPropagation();\n                            window.open('https://datatracker.ietf.org/doc/html/rfc6901', '_blank');\n                          }}\n                        >\n                          <CircleQuestionMark />\n                        </DropdownMenuShortcut>\n                      </DropdownMenuItem>\n                    )}\n                    <DropdownMenuItem className=\"cursor-pointer\" onSelect={() => setJsonPathDialogOpen(true)}>\n                      根据JSON Path展示\n                    </DropdownMenuItem>\n                    <DropdownMenuItem\n                      className=\"cursor-pointer\"\n                      onClick={e => {\n                        setWithButtonGroup(false);\n                        props.onCloseButtonGroup?.(e.nativeEvent);\n                      }}\n                    >\n                      隐藏工具栏\n                    </DropdownMenuItem>\n                  </DropdownMenuGroup>\n                  {!uneditable && (\n                    <>\n                      <DropdownMenuLabel>设置</DropdownMenuLabel>\n                      <DropdownMenuGroup>\n                        <DropdownMenuCheckboxItem\n                          checked={openMove}\n                          className=\"cursor-pointer\"\n                          onCheckedChange={checked => {\n                            setOpenMove(checked);\n                            props.onOpenMoveChange?.(checked);\n                            if (!disableLocalStorage) {\n                              localStorage.setItem(localStorageOpenMoveKey, checked ? 'true' : 'false');\n                            }\n                          }}\n                        >\n                          开启移动\n                        </DropdownMenuCheckboxItem>\n                      </DropdownMenuGroup>\n                    </>\n                  )}\n                </DropdownMenuContent>\n              </DropdownMenu>\n            </ButtonGroup>\n          </div>\n        )}\n      </div>\n      <Dialog open={jsonPathDialogOpen} onOpenChange={setJsonPathDialogOpen}>\n        <JsonPathDialogContent source={data.data} config={props.config} pointer={props.pointer} />\n      </Dialog>\n    </>\n  );\n}\n\nfunction DataViewer(props: DataViewerProps) {\n  return <DataViewerIntl {...props} pointer=\"\" />;\n}\n\nexport default DataViewer;\n\nexport {\n  type DataType,\n  type DataViewerConfig,\n  type DataViewerProps,\n  DataViewer,\n  type InteractionResult,\n  type Interaction,\n  autoDetect,\n};\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/ui/conanyu/data-viewer-app.tsx",
      "content": "import { DataViewer } from '@/components/ui/conanyu/data-viewer.tsx';\nimport { Textarea } from '@/components/ui/textarea.tsx';\nimport { useEffect, useRef, useState } from 'react';\nimport type { ThemeRegistration } from 'shiki';\nimport JSONBigInt from 'json-bigint';\nimport OneLight from 'tm-themes/themes/one-light.json';\nimport { toast } from 'sonner';\nimport { Toaster } from '@/components/ui/sonner.tsx';\nconst JSON = JSONBigInt({ useNativeBigInt: true });\n\nconst localStorageContentKey = 'conanyu-data-viewer.content' as const;\n\nexport default function DataViewerApp() {\n  const [content, setContentState] = useState('');\n  const alerted = useRef(false);\n  const setContent = (value: string) => {\n    setContentState(value);\n    const MAX_SIZE = 100 * 1024;\n    if (value.length <= MAX_SIZE) {\n      localStorage.setItem(localStorageContentKey, value);\n    } else {\n      if (!alerted.current) {\n        toast.warning(`数据内容大小（${value.length}字节）超过最大限制（${MAX_SIZE}字节），将不会保存到浏览器缓存中。`);\n        alerted.current = true;\n      }\n    }\n  };\n  const [themeInfo, setThemeInfo] = useState<ThemeRegistration | undefined>(undefined);\n  useEffect(() => {\n    if (localStorage.getItem(localStorageContentKey)) {\n      setContentState(localStorage.getItem(localStorageContentKey)!);\n    }\n  }, []);\n\n  return (\n    <div className=\"m-4\">\n      <Toaster />\n      <div className=\"grid w-full grid-cols-[max(calc((100%-1rem)/3),300px)_calc(2*max(calc((100%-1rem)/3),300px))] gap-4\">\n        <div className=\"h-[calc(100vh-2rem)]\">\n          <Textarea\n            className=\"h-full resize-none scrollbar-thin bg-gray-100\"\n            placeholder=\"输入数据\"\n            value={content}\n            onChange={e => setContent(e.target.value)}\n          />\n        </div>\n        <div className=\"border-2 rounded-md h-[calc(100vh-2rem)]\">\n          {content.trim() ? (\n            <DataViewer\n              className=\"rounded-md h-full\"\n              preClassName=\"h-full\"\n              data={content}\n              onThemeInfoChange={theme => {\n                setThemeInfo(theme as ThemeRegistration);\n              }}\n              onDataChange={data => setContent(JSON.stringify(data, null, 2))}\n              config={{\n                themeInfo,\n                withToaster: true,\n              }}\n            />\n          ) : (\n            <div\n              className=\"h-full rounded-md\"\n              style={{\n                backgroundColor: themeInfo?.colors?.['editor.background'] || OneLight.colors['editor.background'],\n              }}\n            />\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    }
  ],
  "css": {
    "@plugin tailwind-scrollbar": {}
  }
}